/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsCritical{}).Type1()):                            AlarmSpecEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsInfo{}).Type1()):                                AlarmSpecEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsWarn{}).Type1()):                                AlarmSpecEscalationsWarnCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalations{}).Type1()):                          GroupMetricRuleSpecEscalationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsCritical{}).Type1()):                  GroupMetricRuleSpecEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsInfo{}).Type1()):                      GroupMetricRuleSpecEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsWarn{}).Type1()):                      GroupMetricRuleSpecEscalationsWarnCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalations{}).Type1()):         MetricRuleTemplateSpecAlertTemplatesEscalationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}).Type1()): MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}).Type1()):     MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}).Type1()):     MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsCritical{}).Type1()):                            AlarmSpecEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsInfo{}).Type1()):                                AlarmSpecEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsWarn{}).Type1()):                                AlarmSpecEscalationsWarnCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalations{}).Type1()):                          GroupMetricRuleSpecEscalationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsCritical{}).Type1()):                  GroupMetricRuleSpecEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsInfo{}).Type1()):                      GroupMetricRuleSpecEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsWarn{}).Type1()):                      GroupMetricRuleSpecEscalationsWarnCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalations{}).Type1()):         MetricRuleTemplateSpecAlertTemplatesEscalationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}).Type1()): MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}).Type1()):     MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}).Type1()):     MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AlarmSpecEscalationsCriticalCodec struct {
}

func (AlarmSpecEscalationsCriticalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlarmSpecEscalationsCritical)(ptr) == nil
}

func (AlarmSpecEscalationsCriticalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlarmSpecEscalationsCritical)(ptr)
	var objs []AlarmSpecEscalationsCritical
	if obj != nil {
		objs = []AlarmSpecEscalationsCritical{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsCritical{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlarmSpecEscalationsCriticalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlarmSpecEscalationsCritical)(ptr) = AlarmSpecEscalationsCritical{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlarmSpecEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlarmSpecEscalationsCritical)(ptr) = objs[0]
			} else {
				*(*AlarmSpecEscalationsCritical)(ptr) = AlarmSpecEscalationsCritical{}
			}
		} else {
			*(*AlarmSpecEscalationsCritical)(ptr) = AlarmSpecEscalationsCritical{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AlarmSpecEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AlarmSpecEscalationsCritical)(ptr) = obj
		} else {
			*(*AlarmSpecEscalationsCritical)(ptr) = AlarmSpecEscalationsCritical{}
		}
	default:
		iter.ReportError("decode AlarmSpecEscalationsCritical", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlarmSpecEscalationsInfoCodec struct {
}

func (AlarmSpecEscalationsInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlarmSpecEscalationsInfo)(ptr) == nil
}

func (AlarmSpecEscalationsInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlarmSpecEscalationsInfo)(ptr)
	var objs []AlarmSpecEscalationsInfo
	if obj != nil {
		objs = []AlarmSpecEscalationsInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlarmSpecEscalationsInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlarmSpecEscalationsInfo)(ptr) = AlarmSpecEscalationsInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlarmSpecEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlarmSpecEscalationsInfo)(ptr) = objs[0]
			} else {
				*(*AlarmSpecEscalationsInfo)(ptr) = AlarmSpecEscalationsInfo{}
			}
		} else {
			*(*AlarmSpecEscalationsInfo)(ptr) = AlarmSpecEscalationsInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AlarmSpecEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AlarmSpecEscalationsInfo)(ptr) = obj
		} else {
			*(*AlarmSpecEscalationsInfo)(ptr) = AlarmSpecEscalationsInfo{}
		}
	default:
		iter.ReportError("decode AlarmSpecEscalationsInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlarmSpecEscalationsWarnCodec struct {
}

func (AlarmSpecEscalationsWarnCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlarmSpecEscalationsWarn)(ptr) == nil
}

func (AlarmSpecEscalationsWarnCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlarmSpecEscalationsWarn)(ptr)
	var objs []AlarmSpecEscalationsWarn
	if obj != nil {
		objs = []AlarmSpecEscalationsWarn{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsWarn{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlarmSpecEscalationsWarnCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlarmSpecEscalationsWarn)(ptr) = AlarmSpecEscalationsWarn{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlarmSpecEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlarmSpecEscalationsWarn)(ptr) = objs[0]
			} else {
				*(*AlarmSpecEscalationsWarn)(ptr) = AlarmSpecEscalationsWarn{}
			}
		} else {
			*(*AlarmSpecEscalationsWarn)(ptr) = AlarmSpecEscalationsWarn{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj AlarmSpecEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlarmSpecEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*AlarmSpecEscalationsWarn)(ptr) = obj
		} else {
			*(*AlarmSpecEscalationsWarn)(ptr) = AlarmSpecEscalationsWarn{}
		}
	default:
		iter.ReportError("decode AlarmSpecEscalationsWarn", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupMetricRuleSpecEscalationsCodec struct {
}

func (GroupMetricRuleSpecEscalationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupMetricRuleSpecEscalations)(ptr) == nil
}

func (GroupMetricRuleSpecEscalationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupMetricRuleSpecEscalations)(ptr)
	var objs []GroupMetricRuleSpecEscalations
	if obj != nil {
		objs = []GroupMetricRuleSpecEscalations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupMetricRuleSpecEscalationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupMetricRuleSpecEscalations)(ptr) = GroupMetricRuleSpecEscalations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupMetricRuleSpecEscalations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupMetricRuleSpecEscalations)(ptr) = objs[0]
			} else {
				*(*GroupMetricRuleSpecEscalations)(ptr) = GroupMetricRuleSpecEscalations{}
			}
		} else {
			*(*GroupMetricRuleSpecEscalations)(ptr) = GroupMetricRuleSpecEscalations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupMetricRuleSpecEscalations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupMetricRuleSpecEscalations)(ptr) = obj
		} else {
			*(*GroupMetricRuleSpecEscalations)(ptr) = GroupMetricRuleSpecEscalations{}
		}
	default:
		iter.ReportError("decode GroupMetricRuleSpecEscalations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupMetricRuleSpecEscalationsCriticalCodec struct {
}

func (GroupMetricRuleSpecEscalationsCriticalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupMetricRuleSpecEscalationsCritical)(ptr) == nil
}

func (GroupMetricRuleSpecEscalationsCriticalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupMetricRuleSpecEscalationsCritical)(ptr)
	var objs []GroupMetricRuleSpecEscalationsCritical
	if obj != nil {
		objs = []GroupMetricRuleSpecEscalationsCritical{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsCritical{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupMetricRuleSpecEscalationsCriticalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = GroupMetricRuleSpecEscalationsCritical{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupMetricRuleSpecEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = objs[0]
			} else {
				*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = GroupMetricRuleSpecEscalationsCritical{}
			}
		} else {
			*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = GroupMetricRuleSpecEscalationsCritical{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupMetricRuleSpecEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = obj
		} else {
			*(*GroupMetricRuleSpecEscalationsCritical)(ptr) = GroupMetricRuleSpecEscalationsCritical{}
		}
	default:
		iter.ReportError("decode GroupMetricRuleSpecEscalationsCritical", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupMetricRuleSpecEscalationsInfoCodec struct {
}

func (GroupMetricRuleSpecEscalationsInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupMetricRuleSpecEscalationsInfo)(ptr) == nil
}

func (GroupMetricRuleSpecEscalationsInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupMetricRuleSpecEscalationsInfo)(ptr)
	var objs []GroupMetricRuleSpecEscalationsInfo
	if obj != nil {
		objs = []GroupMetricRuleSpecEscalationsInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupMetricRuleSpecEscalationsInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = GroupMetricRuleSpecEscalationsInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupMetricRuleSpecEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = objs[0]
			} else {
				*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = GroupMetricRuleSpecEscalationsInfo{}
			}
		} else {
			*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = GroupMetricRuleSpecEscalationsInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupMetricRuleSpecEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = obj
		} else {
			*(*GroupMetricRuleSpecEscalationsInfo)(ptr) = GroupMetricRuleSpecEscalationsInfo{}
		}
	default:
		iter.ReportError("decode GroupMetricRuleSpecEscalationsInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupMetricRuleSpecEscalationsWarnCodec struct {
}

func (GroupMetricRuleSpecEscalationsWarnCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupMetricRuleSpecEscalationsWarn)(ptr) == nil
}

func (GroupMetricRuleSpecEscalationsWarnCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupMetricRuleSpecEscalationsWarn)(ptr)
	var objs []GroupMetricRuleSpecEscalationsWarn
	if obj != nil {
		objs = []GroupMetricRuleSpecEscalationsWarn{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsWarn{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupMetricRuleSpecEscalationsWarnCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = GroupMetricRuleSpecEscalationsWarn{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupMetricRuleSpecEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = objs[0]
			} else {
				*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = GroupMetricRuleSpecEscalationsWarn{}
			}
		} else {
			*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = GroupMetricRuleSpecEscalationsWarn{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj GroupMetricRuleSpecEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupMetricRuleSpecEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = obj
		} else {
			*(*GroupMetricRuleSpecEscalationsWarn)(ptr) = GroupMetricRuleSpecEscalationsWarn{}
		}
	default:
		iter.ReportError("decode GroupMetricRuleSpecEscalationsWarn", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricRuleTemplateSpecAlertTemplatesEscalationsCodec struct {
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) == nil
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr)
	var objs []MetricRuleTemplateSpecAlertTemplatesEscalations
	if obj != nil {
		objs = []MetricRuleTemplateSpecAlertTemplatesEscalations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricRuleTemplateSpecAlertTemplatesEscalations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = objs[0]
			} else {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalations{}
			}
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalations{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricRuleTemplateSpecAlertTemplatesEscalations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = obj
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalations)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalations{}
		}
	default:
		iter.ReportError("decode MetricRuleTemplateSpecAlertTemplatesEscalations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec struct {
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) == nil
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr)
	var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsCritical
	if obj != nil {
		objs = []MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsCriticalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = objs[0]
			} else {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}
			}
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricRuleTemplateSpecAlertTemplatesEscalationsCritical

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = obj
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsCritical)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsCritical{}
		}
	default:
		iter.ReportError("decode MetricRuleTemplateSpecAlertTemplatesEscalationsCritical", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec struct {
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) == nil
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr)
	var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsInfo
	if obj != nil {
		objs = []MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = objs[0]
			} else {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}
			}
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricRuleTemplateSpecAlertTemplatesEscalationsInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = obj
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsInfo)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsInfo{}
		}
	default:
		iter.ReportError("decode MetricRuleTemplateSpecAlertTemplatesEscalationsInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec struct {
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) == nil
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr)
	var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsWarn
	if obj != nil {
		objs = []MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricRuleTemplateSpecAlertTemplatesEscalationsWarnCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricRuleTemplateSpecAlertTemplatesEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = objs[0]
			} else {
				*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}
			}
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MetricRuleTemplateSpecAlertTemplatesEscalationsWarn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = obj
		} else {
			*(*MetricRuleTemplateSpecAlertTemplatesEscalationsWarn)(ptr) = MetricRuleTemplateSpecAlertTemplatesEscalationsWarn{}
		}
	default:
		iter.ReportError("decode MetricRuleTemplateSpecAlertTemplatesEscalationsWarn", "unexpected JSON type")
	}
}
