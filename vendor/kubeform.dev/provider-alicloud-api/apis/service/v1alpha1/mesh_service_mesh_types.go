/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
	"sigs.k8s.io/cli-utils/pkg/kstatus/status"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type MeshServiceMesh struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MeshServiceMeshSpec   `json:"spec,omitempty"`
	Status            MeshServiceMeshStatus `json:"status,omitempty"`
}

type MeshServiceMeshSpecLoadBalancer struct {
	// +optional
	ApiServerLoadbalancerID *string `json:"apiServerLoadbalancerID,omitempty" tf:"api_server_loadbalancer_id"`
	// +optional
	ApiServerPublicEip *bool `json:"apiServerPublicEip,omitempty" tf:"api_server_public_eip"`
	// +optional
	PilotPublicEip *bool `json:"pilotPublicEip,omitempty" tf:"pilot_public_eip"`
	// +optional
	PilotPublicLoadbalancerID *string `json:"pilotPublicLoadbalancerID,omitempty" tf:"pilot_public_loadbalancer_id"`
}

type MeshServiceMeshSpecMeshConfigAccessLog struct {
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
}

type MeshServiceMeshSpecMeshConfigAudit struct {
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
}

type MeshServiceMeshSpecMeshConfigKiali struct {
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
}

type MeshServiceMeshSpecMeshConfigOpa struct {
	// +optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`
	// +optional
	LimitCPU *string `json:"limitCPU,omitempty" tf:"limit_cpu"`
	// +optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory"`
	// +optional
	LogLevel *string `json:"logLevel,omitempty" tf:"log_level"`
	// +optional
	RequestCPU *string `json:"requestCPU,omitempty" tf:"request_cpu"`
	// +optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory"`
}

type MeshServiceMeshSpecMeshConfigPilot struct {
	// +optional
	Http10Enabled *bool `json:"http10Enabled,omitempty" tf:"http10_enabled"`
	// +optional
	TraceSampling *float64 `json:"traceSampling,omitempty" tf:"trace_sampling"`
}

type MeshServiceMeshSpecMeshConfigProxy struct {
	// +optional
	LimitCPU *string `json:"limitCPU,omitempty" tf:"limit_cpu"`
	// +optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory"`
	// +optional
	RequestCPU *string `json:"requestCPU,omitempty" tf:"request_cpu"`
	// +optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory"`
}

type MeshServiceMeshSpecMeshConfigSidecarInjector struct {
	// +optional
	AutoInjectionPolicyEnabled *bool `json:"autoInjectionPolicyEnabled,omitempty" tf:"auto_injection_policy_enabled"`
	// +optional
	EnableNamespacesByDefault *bool `json:"enableNamespacesByDefault,omitempty" tf:"enable_namespaces_by_default"`
	// +optional
	LimitCPU *string `json:"limitCPU,omitempty" tf:"limit_cpu"`
	// +optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory"`
	// +optional
	RequestCPU *string `json:"requestCPU,omitempty" tf:"request_cpu"`
	// +optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory"`
}

type MeshServiceMeshSpecMeshConfig struct {
	// +optional
	AccessLog *MeshServiceMeshSpecMeshConfigAccessLog `json:"accessLog,omitempty" tf:"access_log"`
	// +optional
	Audit *MeshServiceMeshSpecMeshConfigAudit `json:"audit,omitempty" tf:"audit"`
	// +optional
	CustomizedZipkin *bool `json:"customizedZipkin,omitempty" tf:"customized_zipkin"`
	// +optional
	EnableLocalityLb *bool `json:"enableLocalityLb,omitempty" tf:"enable_locality_lb"`
	// +optional
	Kiali *MeshServiceMeshSpecMeshConfigKiali `json:"kiali,omitempty" tf:"kiali"`
	// +optional
	Opa *MeshServiceMeshSpecMeshConfigOpa `json:"opa,omitempty" tf:"opa"`
	// +optional
	OutboundTrafficPolicy *string `json:"outboundTrafficPolicy,omitempty" tf:"outbound_traffic_policy"`
	// +optional
	Pilot *MeshServiceMeshSpecMeshConfigPilot `json:"pilot,omitempty" tf:"pilot"`
	// +optional
	Proxy *MeshServiceMeshSpecMeshConfigProxy `json:"proxy,omitempty" tf:"proxy"`
	// +optional
	SidecarInjector *MeshServiceMeshSpecMeshConfigSidecarInjector `json:"sidecarInjector,omitempty" tf:"sidecar_injector"`
	// +optional
	Telemetry *bool `json:"telemetry,omitempty" tf:"telemetry"`
	// +optional
	Tracing *bool `json:"tracing,omitempty" tf:"tracing"`
}

type MeshServiceMeshSpecNetwork struct {
	VpcID        *string  `json:"vpcID" tf:"vpc_id"`
	VswitcheList []string `json:"vswitcheList" tf:"vswitche_list"`
}

type MeshServiceMeshSpec struct {
	State *MeshServiceMeshSpecResource `json:"state,omitempty" tf:"-"`

	Resource MeshServiceMeshSpecResource `json:"resource" tf:"resource"`

	UpdatePolicy base.UpdatePolicy `json:"updatePolicy,omitempty" tf:"-"`

	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	BackendRef *core.LocalObjectReference `json:"backendRef,omitempty" tf:"-"`
}

type MeshServiceMeshSpecResource struct {
	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// +optional
	Edition *string `json:"edition,omitempty" tf:"edition"`
	// +optional
	Force *bool `json:"force,omitempty" tf:"force"`
	// +optional
	LoadBalancer *MeshServiceMeshSpecLoadBalancer `json:"loadBalancer,omitempty" tf:"load_balancer"`
	// +optional
	MeshConfig *MeshServiceMeshSpecMeshConfig `json:"meshConfig,omitempty" tf:"mesh_config"`
	Network    *MeshServiceMeshSpecNetwork    `json:"network" tf:"network"`
	// +optional
	ServiceMeshName *string `json:"serviceMeshName,omitempty" tf:"service_mesh_name"`
	// +optional
	Status *string `json:"status,omitempty" tf:"status"`
	// +optional
	Version *string `json:"version,omitempty" tf:"version"`
}

type MeshServiceMeshStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase status.Status `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// MeshServiceMeshList is a list of MeshServiceMeshs
type MeshServiceMeshList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of MeshServiceMesh CRD objects
	Items []MeshServiceMesh `json:"items,omitempty"`
}
