/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecLoadBalancer{}).Type1()):              MeshServiceMeshSpecLoadBalancerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfig{}).Type1()):                MeshServiceMeshSpecMeshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAccessLog{}).Type1()):       MeshServiceMeshSpecMeshConfigAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAudit{}).Type1()):           MeshServiceMeshSpecMeshConfigAuditCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigKiali{}).Type1()):           MeshServiceMeshSpecMeshConfigKialiCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigOpa{}).Type1()):             MeshServiceMeshSpecMeshConfigOpaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigPilot{}).Type1()):           MeshServiceMeshSpecMeshConfigPilotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigProxy{}).Type1()):           MeshServiceMeshSpecMeshConfigProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigSidecarInjector{}).Type1()): MeshServiceMeshSpecMeshConfigSidecarInjectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecNetwork{}).Type1()):                   MeshServiceMeshSpecNetworkCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecLoadBalancer{}).Type1()):              MeshServiceMeshSpecLoadBalancerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfig{}).Type1()):                MeshServiceMeshSpecMeshConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAccessLog{}).Type1()):       MeshServiceMeshSpecMeshConfigAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAudit{}).Type1()):           MeshServiceMeshSpecMeshConfigAuditCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigKiali{}).Type1()):           MeshServiceMeshSpecMeshConfigKialiCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigOpa{}).Type1()):             MeshServiceMeshSpecMeshConfigOpaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigPilot{}).Type1()):           MeshServiceMeshSpecMeshConfigPilotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigProxy{}).Type1()):           MeshServiceMeshSpecMeshConfigProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigSidecarInjector{}).Type1()): MeshServiceMeshSpecMeshConfigSidecarInjectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecNetwork{}).Type1()):                   MeshServiceMeshSpecNetworkCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecLoadBalancerCodec struct {
}

func (MeshServiceMeshSpecLoadBalancerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecLoadBalancer)(ptr) == nil
}

func (MeshServiceMeshSpecLoadBalancerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecLoadBalancer)(ptr)
	var objs []MeshServiceMeshSpecLoadBalancer
	if obj != nil {
		objs = []MeshServiceMeshSpecLoadBalancer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecLoadBalancer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecLoadBalancerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecLoadBalancer)(ptr) = MeshServiceMeshSpecLoadBalancer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecLoadBalancer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecLoadBalancer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecLoadBalancer)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecLoadBalancer)(ptr) = MeshServiceMeshSpecLoadBalancer{}
			}
		} else {
			*(*MeshServiceMeshSpecLoadBalancer)(ptr) = MeshServiceMeshSpecLoadBalancer{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecLoadBalancer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecLoadBalancer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecLoadBalancer)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecLoadBalancer)(ptr) = MeshServiceMeshSpecLoadBalancer{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecLoadBalancer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigCodec struct {
}

func (MeshServiceMeshSpecMeshConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfig)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfig)(ptr)
	var objs []MeshServiceMeshSpecMeshConfig
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfig)(ptr) = MeshServiceMeshSpecMeshConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfig)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfig)(ptr) = MeshServiceMeshSpecMeshConfig{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfig)(ptr) = MeshServiceMeshSpecMeshConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfig)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfig)(ptr) = MeshServiceMeshSpecMeshConfig{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigAccessLogCodec struct {
}

func (MeshServiceMeshSpecMeshConfigAccessLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigAccessLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigAccessLog)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigAccessLog
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigAccessLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAccessLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigAccessLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = MeshServiceMeshSpecMeshConfigAccessLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = MeshServiceMeshSpecMeshConfigAccessLog{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = MeshServiceMeshSpecMeshConfigAccessLog{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigAccessLog)(ptr) = MeshServiceMeshSpecMeshConfigAccessLog{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigAccessLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigAuditCodec struct {
}

func (MeshServiceMeshSpecMeshConfigAuditCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigAudit)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigAuditCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigAudit)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigAudit
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigAudit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAudit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigAuditCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = MeshServiceMeshSpecMeshConfigAudit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigAudit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAudit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = MeshServiceMeshSpecMeshConfigAudit{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = MeshServiceMeshSpecMeshConfigAudit{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigAudit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigAudit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigAudit)(ptr) = MeshServiceMeshSpecMeshConfigAudit{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigAudit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigKialiCodec struct {
}

func (MeshServiceMeshSpecMeshConfigKialiCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigKiali)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigKialiCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigKiali)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigKiali
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigKiali{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigKiali{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigKialiCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = MeshServiceMeshSpecMeshConfigKiali{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigKiali

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigKiali{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = MeshServiceMeshSpecMeshConfigKiali{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = MeshServiceMeshSpecMeshConfigKiali{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigKiali

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigKiali{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigKiali)(ptr) = MeshServiceMeshSpecMeshConfigKiali{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigKiali", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigOpaCodec struct {
}

func (MeshServiceMeshSpecMeshConfigOpaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigOpa)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigOpaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigOpa)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigOpa
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigOpa{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigOpa{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigOpaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = MeshServiceMeshSpecMeshConfigOpa{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigOpa

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigOpa{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = MeshServiceMeshSpecMeshConfigOpa{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = MeshServiceMeshSpecMeshConfigOpa{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigOpa

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigOpa{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigOpa)(ptr) = MeshServiceMeshSpecMeshConfigOpa{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigOpa", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigPilotCodec struct {
}

func (MeshServiceMeshSpecMeshConfigPilotCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigPilot)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigPilotCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigPilot)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigPilot
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigPilot{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigPilot{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigPilotCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = MeshServiceMeshSpecMeshConfigPilot{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigPilot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigPilot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = MeshServiceMeshSpecMeshConfigPilot{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = MeshServiceMeshSpecMeshConfigPilot{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigPilot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigPilot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigPilot)(ptr) = MeshServiceMeshSpecMeshConfigPilot{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigPilot", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigProxyCodec struct {
}

func (MeshServiceMeshSpecMeshConfigProxyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigProxy)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigProxyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigProxy)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigProxy
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigProxy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigProxy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigProxyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = MeshServiceMeshSpecMeshConfigProxy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = MeshServiceMeshSpecMeshConfigProxy{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = MeshServiceMeshSpecMeshConfigProxy{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigProxy)(ptr) = MeshServiceMeshSpecMeshConfigProxy{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigProxy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecMeshConfigSidecarInjectorCodec struct {
}

func (MeshServiceMeshSpecMeshConfigSidecarInjectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) == nil
}

func (MeshServiceMeshSpecMeshConfigSidecarInjectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr)
	var objs []MeshServiceMeshSpecMeshConfigSidecarInjector
	if obj != nil {
		objs = []MeshServiceMeshSpecMeshConfigSidecarInjector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigSidecarInjector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecMeshConfigSidecarInjectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = MeshServiceMeshSpecMeshConfigSidecarInjector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecMeshConfigSidecarInjector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigSidecarInjector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = MeshServiceMeshSpecMeshConfigSidecarInjector{}
			}
		} else {
			*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = MeshServiceMeshSpecMeshConfigSidecarInjector{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecMeshConfigSidecarInjector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecMeshConfigSidecarInjector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecMeshConfigSidecarInjector)(ptr) = MeshServiceMeshSpecMeshConfigSidecarInjector{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecMeshConfigSidecarInjector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshServiceMeshSpecNetworkCodec struct {
}

func (MeshServiceMeshSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshServiceMeshSpecNetwork)(ptr) == nil
}

func (MeshServiceMeshSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshServiceMeshSpecNetwork)(ptr)
	var objs []MeshServiceMeshSpecNetwork
	if obj != nil {
		objs = []MeshServiceMeshSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshServiceMeshSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshServiceMeshSpecNetwork)(ptr) = MeshServiceMeshSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshServiceMeshSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshServiceMeshSpecNetwork)(ptr) = objs[0]
			} else {
				*(*MeshServiceMeshSpecNetwork)(ptr) = MeshServiceMeshSpecNetwork{}
			}
		} else {
			*(*MeshServiceMeshSpecNetwork)(ptr) = MeshServiceMeshSpecNetwork{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj MeshServiceMeshSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshServiceMeshSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*MeshServiceMeshSpecNetwork)(ptr) = obj
		} else {
			*(*MeshServiceMeshSpecNetwork)(ptr) = MeshServiceMeshSpecNetwork{}
		}
	default:
		iter.ReportError("decode MeshServiceMeshSpecNetwork", "unexpected JSON type")
	}
}
