/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAccessLogTracingConfig{}).Type1()):           ListenerSpecAccessLogTracingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAclConfig{}).Type1()):                        ListenerSpecAclConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionsForwardGroupConfig{}).Type1()): ListenerSpecDefaultActionsForwardGroupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecQuicConfig{}).Type1()):                       ListenerSpecQuicConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecXforwardedForConfig{}).Type1()):              ListenerSpecXforwardedForConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecAccessLogConfig{}).Type1()):              LoadBalancerSpecAccessLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecLoadBalancerBillingConfig{}).Type1()):    LoadBalancerSpecLoadBalancerBillingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecModificationProtectionConfig{}).Type1()): LoadBalancerSpecModificationProtectionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsFixedResponseConfig{}).Type1()):       RuleSpecRuleActionsFixedResponseConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsForwardGroupConfig{}).Type1()):        RuleSpecRuleActionsForwardGroupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsInsertHeaderConfig{}).Type1()):        RuleSpecRuleActionsInsertHeaderConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRedirectConfig{}).Type1()):            RuleSpecRuleActionsRedirectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRewriteConfig{}).Type1()):             RuleSpecRuleActionsRewriteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsCookieConfig{}).Type1()):           RuleSpecRuleConditionsCookieConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHeaderConfig{}).Type1()):           RuleSpecRuleConditionsHeaderConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHostConfig{}).Type1()):             RuleSpecRuleConditionsHostConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsMethodConfig{}).Type1()):           RuleSpecRuleConditionsMethodConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsPathConfig{}).Type1()):             RuleSpecRuleConditionsPathConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsQueryStringConfig{}).Type1()):      RuleSpecRuleConditionsQueryStringConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecHealthCheckConfig{}).Type1()):             ServerGroupSpecHealthCheckConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecStickySessionConfig{}).Type1()):           ServerGroupSpecStickySessionConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAccessLogTracingConfig{}).Type1()):           ListenerSpecAccessLogTracingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAclConfig{}).Type1()):                        ListenerSpecAclConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionsForwardGroupConfig{}).Type1()): ListenerSpecDefaultActionsForwardGroupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecQuicConfig{}).Type1()):                       ListenerSpecQuicConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecXforwardedForConfig{}).Type1()):              ListenerSpecXforwardedForConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecAccessLogConfig{}).Type1()):              LoadBalancerSpecAccessLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecLoadBalancerBillingConfig{}).Type1()):    LoadBalancerSpecLoadBalancerBillingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecModificationProtectionConfig{}).Type1()): LoadBalancerSpecModificationProtectionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsFixedResponseConfig{}).Type1()):       RuleSpecRuleActionsFixedResponseConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsForwardGroupConfig{}).Type1()):        RuleSpecRuleActionsForwardGroupConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsInsertHeaderConfig{}).Type1()):        RuleSpecRuleActionsInsertHeaderConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRedirectConfig{}).Type1()):            RuleSpecRuleActionsRedirectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRewriteConfig{}).Type1()):             RuleSpecRuleActionsRewriteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsCookieConfig{}).Type1()):           RuleSpecRuleConditionsCookieConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHeaderConfig{}).Type1()):           RuleSpecRuleConditionsHeaderConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHostConfig{}).Type1()):             RuleSpecRuleConditionsHostConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsMethodConfig{}).Type1()):           RuleSpecRuleConditionsMethodConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsPathConfig{}).Type1()):             RuleSpecRuleConditionsPathConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsQueryStringConfig{}).Type1()):      RuleSpecRuleConditionsQueryStringConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecHealthCheckConfig{}).Type1()):             ServerGroupSpecHealthCheckConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecStickySessionConfig{}).Type1()):           ServerGroupSpecStickySessionConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ListenerSpecAccessLogTracingConfigCodec struct {
}

func (ListenerSpecAccessLogTracingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecAccessLogTracingConfig)(ptr) == nil
}

func (ListenerSpecAccessLogTracingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecAccessLogTracingConfig)(ptr)
	var objs []ListenerSpecAccessLogTracingConfig
	if obj != nil {
		objs = []ListenerSpecAccessLogTracingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAccessLogTracingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecAccessLogTracingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecAccessLogTracingConfig)(ptr) = ListenerSpecAccessLogTracingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecAccessLogTracingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAccessLogTracingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecAccessLogTracingConfig)(ptr) = objs[0]
			} else {
				*(*ListenerSpecAccessLogTracingConfig)(ptr) = ListenerSpecAccessLogTracingConfig{}
			}
		} else {
			*(*ListenerSpecAccessLogTracingConfig)(ptr) = ListenerSpecAccessLogTracingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecAccessLogTracingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAccessLogTracingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecAccessLogTracingConfig)(ptr) = obj
		} else {
			*(*ListenerSpecAccessLogTracingConfig)(ptr) = ListenerSpecAccessLogTracingConfig{}
		}
	default:
		iter.ReportError("decode ListenerSpecAccessLogTracingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecAclConfigCodec struct {
}

func (ListenerSpecAclConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecAclConfig)(ptr) == nil
}

func (ListenerSpecAclConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecAclConfig)(ptr)
	var objs []ListenerSpecAclConfig
	if obj != nil {
		objs = []ListenerSpecAclConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAclConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecAclConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecAclConfig)(ptr) = ListenerSpecAclConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecAclConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAclConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecAclConfig)(ptr) = objs[0]
			} else {
				*(*ListenerSpecAclConfig)(ptr) = ListenerSpecAclConfig{}
			}
		} else {
			*(*ListenerSpecAclConfig)(ptr) = ListenerSpecAclConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecAclConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecAclConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecAclConfig)(ptr) = obj
		} else {
			*(*ListenerSpecAclConfig)(ptr) = ListenerSpecAclConfig{}
		}
	default:
		iter.ReportError("decode ListenerSpecAclConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionsForwardGroupConfigCodec struct {
}

func (ListenerSpecDefaultActionsForwardGroupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) == nil
}

func (ListenerSpecDefaultActionsForwardGroupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionsForwardGroupConfig)(ptr)
	var objs []ListenerSpecDefaultActionsForwardGroupConfig
	if obj != nil {
		objs = []ListenerSpecDefaultActionsForwardGroupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionsForwardGroupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionsForwardGroupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = ListenerSpecDefaultActionsForwardGroupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionsForwardGroupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionsForwardGroupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = ListenerSpecDefaultActionsForwardGroupConfig{}
			}
		} else {
			*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = ListenerSpecDefaultActionsForwardGroupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecDefaultActionsForwardGroupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionsForwardGroupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = obj
		} else {
			*(*ListenerSpecDefaultActionsForwardGroupConfig)(ptr) = ListenerSpecDefaultActionsForwardGroupConfig{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionsForwardGroupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecQuicConfigCodec struct {
}

func (ListenerSpecQuicConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecQuicConfig)(ptr) == nil
}

func (ListenerSpecQuicConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecQuicConfig)(ptr)
	var objs []ListenerSpecQuicConfig
	if obj != nil {
		objs = []ListenerSpecQuicConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecQuicConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecQuicConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecQuicConfig)(ptr) = ListenerSpecQuicConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecQuicConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecQuicConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecQuicConfig)(ptr) = objs[0]
			} else {
				*(*ListenerSpecQuicConfig)(ptr) = ListenerSpecQuicConfig{}
			}
		} else {
			*(*ListenerSpecQuicConfig)(ptr) = ListenerSpecQuicConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecQuicConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecQuicConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecQuicConfig)(ptr) = obj
		} else {
			*(*ListenerSpecQuicConfig)(ptr) = ListenerSpecQuicConfig{}
		}
	default:
		iter.ReportError("decode ListenerSpecQuicConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecXforwardedForConfigCodec struct {
}

func (ListenerSpecXforwardedForConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecXforwardedForConfig)(ptr) == nil
}

func (ListenerSpecXforwardedForConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecXforwardedForConfig)(ptr)
	var objs []ListenerSpecXforwardedForConfig
	if obj != nil {
		objs = []ListenerSpecXforwardedForConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecXforwardedForConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecXforwardedForConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecXforwardedForConfig)(ptr) = ListenerSpecXforwardedForConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecXforwardedForConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecXforwardedForConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecXforwardedForConfig)(ptr) = objs[0]
			} else {
				*(*ListenerSpecXforwardedForConfig)(ptr) = ListenerSpecXforwardedForConfig{}
			}
		} else {
			*(*ListenerSpecXforwardedForConfig)(ptr) = ListenerSpecXforwardedForConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ListenerSpecXforwardedForConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecXforwardedForConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ListenerSpecXforwardedForConfig)(ptr) = obj
		} else {
			*(*ListenerSpecXforwardedForConfig)(ptr) = ListenerSpecXforwardedForConfig{}
		}
	default:
		iter.ReportError("decode ListenerSpecXforwardedForConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoadBalancerSpecAccessLogConfigCodec struct {
}

func (LoadBalancerSpecAccessLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoadBalancerSpecAccessLogConfig)(ptr) == nil
}

func (LoadBalancerSpecAccessLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoadBalancerSpecAccessLogConfig)(ptr)
	var objs []LoadBalancerSpecAccessLogConfig
	if obj != nil {
		objs = []LoadBalancerSpecAccessLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecAccessLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoadBalancerSpecAccessLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoadBalancerSpecAccessLogConfig)(ptr) = LoadBalancerSpecAccessLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoadBalancerSpecAccessLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecAccessLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoadBalancerSpecAccessLogConfig)(ptr) = objs[0]
			} else {
				*(*LoadBalancerSpecAccessLogConfig)(ptr) = LoadBalancerSpecAccessLogConfig{}
			}
		} else {
			*(*LoadBalancerSpecAccessLogConfig)(ptr) = LoadBalancerSpecAccessLogConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoadBalancerSpecAccessLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecAccessLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoadBalancerSpecAccessLogConfig)(ptr) = obj
		} else {
			*(*LoadBalancerSpecAccessLogConfig)(ptr) = LoadBalancerSpecAccessLogConfig{}
		}
	default:
		iter.ReportError("decode LoadBalancerSpecAccessLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoadBalancerSpecLoadBalancerBillingConfigCodec struct {
}

func (LoadBalancerSpecLoadBalancerBillingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) == nil
}

func (LoadBalancerSpecLoadBalancerBillingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoadBalancerSpecLoadBalancerBillingConfig)(ptr)
	var objs []LoadBalancerSpecLoadBalancerBillingConfig
	if obj != nil {
		objs = []LoadBalancerSpecLoadBalancerBillingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecLoadBalancerBillingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoadBalancerSpecLoadBalancerBillingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = LoadBalancerSpecLoadBalancerBillingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoadBalancerSpecLoadBalancerBillingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecLoadBalancerBillingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = objs[0]
			} else {
				*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = LoadBalancerSpecLoadBalancerBillingConfig{}
			}
		} else {
			*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = LoadBalancerSpecLoadBalancerBillingConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoadBalancerSpecLoadBalancerBillingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecLoadBalancerBillingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = obj
		} else {
			*(*LoadBalancerSpecLoadBalancerBillingConfig)(ptr) = LoadBalancerSpecLoadBalancerBillingConfig{}
		}
	default:
		iter.ReportError("decode LoadBalancerSpecLoadBalancerBillingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoadBalancerSpecModificationProtectionConfigCodec struct {
}

func (LoadBalancerSpecModificationProtectionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoadBalancerSpecModificationProtectionConfig)(ptr) == nil
}

func (LoadBalancerSpecModificationProtectionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoadBalancerSpecModificationProtectionConfig)(ptr)
	var objs []LoadBalancerSpecModificationProtectionConfig
	if obj != nil {
		objs = []LoadBalancerSpecModificationProtectionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecModificationProtectionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoadBalancerSpecModificationProtectionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = LoadBalancerSpecModificationProtectionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoadBalancerSpecModificationProtectionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecModificationProtectionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = objs[0]
			} else {
				*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = LoadBalancerSpecModificationProtectionConfig{}
			}
		} else {
			*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = LoadBalancerSpecModificationProtectionConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj LoadBalancerSpecModificationProtectionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoadBalancerSpecModificationProtectionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = obj
		} else {
			*(*LoadBalancerSpecModificationProtectionConfig)(ptr) = LoadBalancerSpecModificationProtectionConfig{}
		}
	default:
		iter.ReportError("decode LoadBalancerSpecModificationProtectionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleActionsFixedResponseConfigCodec struct {
}

func (RuleSpecRuleActionsFixedResponseConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleActionsFixedResponseConfig)(ptr) == nil
}

func (RuleSpecRuleActionsFixedResponseConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleActionsFixedResponseConfig)(ptr)
	var objs []RuleSpecRuleActionsFixedResponseConfig
	if obj != nil {
		objs = []RuleSpecRuleActionsFixedResponseConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsFixedResponseConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleActionsFixedResponseConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = RuleSpecRuleActionsFixedResponseConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleActionsFixedResponseConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsFixedResponseConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = RuleSpecRuleActionsFixedResponseConfig{}
			}
		} else {
			*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = RuleSpecRuleActionsFixedResponseConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleActionsFixedResponseConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsFixedResponseConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleActionsFixedResponseConfig)(ptr) = RuleSpecRuleActionsFixedResponseConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleActionsFixedResponseConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleActionsForwardGroupConfigCodec struct {
}

func (RuleSpecRuleActionsForwardGroupConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleActionsForwardGroupConfig)(ptr) == nil
}

func (RuleSpecRuleActionsForwardGroupConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleActionsForwardGroupConfig)(ptr)
	var objs []RuleSpecRuleActionsForwardGroupConfig
	if obj != nil {
		objs = []RuleSpecRuleActionsForwardGroupConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsForwardGroupConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleActionsForwardGroupConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = RuleSpecRuleActionsForwardGroupConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleActionsForwardGroupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsForwardGroupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = RuleSpecRuleActionsForwardGroupConfig{}
			}
		} else {
			*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = RuleSpecRuleActionsForwardGroupConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleActionsForwardGroupConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsForwardGroupConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleActionsForwardGroupConfig)(ptr) = RuleSpecRuleActionsForwardGroupConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleActionsForwardGroupConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleActionsInsertHeaderConfigCodec struct {
}

func (RuleSpecRuleActionsInsertHeaderConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleActionsInsertHeaderConfig)(ptr) == nil
}

func (RuleSpecRuleActionsInsertHeaderConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleActionsInsertHeaderConfig)(ptr)
	var objs []RuleSpecRuleActionsInsertHeaderConfig
	if obj != nil {
		objs = []RuleSpecRuleActionsInsertHeaderConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsInsertHeaderConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleActionsInsertHeaderConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = RuleSpecRuleActionsInsertHeaderConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleActionsInsertHeaderConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsInsertHeaderConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = RuleSpecRuleActionsInsertHeaderConfig{}
			}
		} else {
			*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = RuleSpecRuleActionsInsertHeaderConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleActionsInsertHeaderConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsInsertHeaderConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleActionsInsertHeaderConfig)(ptr) = RuleSpecRuleActionsInsertHeaderConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleActionsInsertHeaderConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleActionsRedirectConfigCodec struct {
}

func (RuleSpecRuleActionsRedirectConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleActionsRedirectConfig)(ptr) == nil
}

func (RuleSpecRuleActionsRedirectConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleActionsRedirectConfig)(ptr)
	var objs []RuleSpecRuleActionsRedirectConfig
	if obj != nil {
		objs = []RuleSpecRuleActionsRedirectConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRedirectConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleActionsRedirectConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleActionsRedirectConfig)(ptr) = RuleSpecRuleActionsRedirectConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleActionsRedirectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRedirectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleActionsRedirectConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleActionsRedirectConfig)(ptr) = RuleSpecRuleActionsRedirectConfig{}
			}
		} else {
			*(*RuleSpecRuleActionsRedirectConfig)(ptr) = RuleSpecRuleActionsRedirectConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleActionsRedirectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRedirectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleActionsRedirectConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleActionsRedirectConfig)(ptr) = RuleSpecRuleActionsRedirectConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleActionsRedirectConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleActionsRewriteConfigCodec struct {
}

func (RuleSpecRuleActionsRewriteConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleActionsRewriteConfig)(ptr) == nil
}

func (RuleSpecRuleActionsRewriteConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleActionsRewriteConfig)(ptr)
	var objs []RuleSpecRuleActionsRewriteConfig
	if obj != nil {
		objs = []RuleSpecRuleActionsRewriteConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRewriteConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleActionsRewriteConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleActionsRewriteConfig)(ptr) = RuleSpecRuleActionsRewriteConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleActionsRewriteConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRewriteConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleActionsRewriteConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleActionsRewriteConfig)(ptr) = RuleSpecRuleActionsRewriteConfig{}
			}
		} else {
			*(*RuleSpecRuleActionsRewriteConfig)(ptr) = RuleSpecRuleActionsRewriteConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleActionsRewriteConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleActionsRewriteConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleActionsRewriteConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleActionsRewriteConfig)(ptr) = RuleSpecRuleActionsRewriteConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleActionsRewriteConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsCookieConfigCodec struct {
}

func (RuleSpecRuleConditionsCookieConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsCookieConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsCookieConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsCookieConfig)(ptr)
	var objs []RuleSpecRuleConditionsCookieConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsCookieConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsCookieConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsCookieConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsCookieConfig)(ptr) = RuleSpecRuleConditionsCookieConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsCookieConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsCookieConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsCookieConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsCookieConfig)(ptr) = RuleSpecRuleConditionsCookieConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsCookieConfig)(ptr) = RuleSpecRuleConditionsCookieConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsCookieConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsCookieConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsCookieConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsCookieConfig)(ptr) = RuleSpecRuleConditionsCookieConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsCookieConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsHeaderConfigCodec struct {
}

func (RuleSpecRuleConditionsHeaderConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsHeaderConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsHeaderConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsHeaderConfig)(ptr)
	var objs []RuleSpecRuleConditionsHeaderConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsHeaderConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHeaderConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsHeaderConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = RuleSpecRuleConditionsHeaderConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsHeaderConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHeaderConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = RuleSpecRuleConditionsHeaderConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = RuleSpecRuleConditionsHeaderConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsHeaderConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHeaderConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsHeaderConfig)(ptr) = RuleSpecRuleConditionsHeaderConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsHeaderConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsHostConfigCodec struct {
}

func (RuleSpecRuleConditionsHostConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsHostConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsHostConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsHostConfig)(ptr)
	var objs []RuleSpecRuleConditionsHostConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsHostConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHostConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsHostConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsHostConfig)(ptr) = RuleSpecRuleConditionsHostConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsHostConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHostConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsHostConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsHostConfig)(ptr) = RuleSpecRuleConditionsHostConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsHostConfig)(ptr) = RuleSpecRuleConditionsHostConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsHostConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsHostConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsHostConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsHostConfig)(ptr) = RuleSpecRuleConditionsHostConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsHostConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsMethodConfigCodec struct {
}

func (RuleSpecRuleConditionsMethodConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsMethodConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsMethodConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsMethodConfig)(ptr)
	var objs []RuleSpecRuleConditionsMethodConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsMethodConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsMethodConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsMethodConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsMethodConfig)(ptr) = RuleSpecRuleConditionsMethodConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsMethodConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsMethodConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsMethodConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsMethodConfig)(ptr) = RuleSpecRuleConditionsMethodConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsMethodConfig)(ptr) = RuleSpecRuleConditionsMethodConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsMethodConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsMethodConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsMethodConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsMethodConfig)(ptr) = RuleSpecRuleConditionsMethodConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsMethodConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsPathConfigCodec struct {
}

func (RuleSpecRuleConditionsPathConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsPathConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsPathConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsPathConfig)(ptr)
	var objs []RuleSpecRuleConditionsPathConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsPathConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsPathConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsPathConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsPathConfig)(ptr) = RuleSpecRuleConditionsPathConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsPathConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsPathConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsPathConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsPathConfig)(ptr) = RuleSpecRuleConditionsPathConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsPathConfig)(ptr) = RuleSpecRuleConditionsPathConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsPathConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsPathConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsPathConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsPathConfig)(ptr) = RuleSpecRuleConditionsPathConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsPathConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleSpecRuleConditionsQueryStringConfigCodec struct {
}

func (RuleSpecRuleConditionsQueryStringConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleSpecRuleConditionsQueryStringConfig)(ptr) == nil
}

func (RuleSpecRuleConditionsQueryStringConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleSpecRuleConditionsQueryStringConfig)(ptr)
	var objs []RuleSpecRuleConditionsQueryStringConfig
	if obj != nil {
		objs = []RuleSpecRuleConditionsQueryStringConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsQueryStringConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleSpecRuleConditionsQueryStringConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = RuleSpecRuleConditionsQueryStringConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleSpecRuleConditionsQueryStringConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsQueryStringConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = objs[0]
			} else {
				*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = RuleSpecRuleConditionsQueryStringConfig{}
			}
		} else {
			*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = RuleSpecRuleConditionsQueryStringConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj RuleSpecRuleConditionsQueryStringConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleSpecRuleConditionsQueryStringConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = obj
		} else {
			*(*RuleSpecRuleConditionsQueryStringConfig)(ptr) = RuleSpecRuleConditionsQueryStringConfig{}
		}
	default:
		iter.ReportError("decode RuleSpecRuleConditionsQueryStringConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerGroupSpecHealthCheckConfigCodec struct {
}

func (ServerGroupSpecHealthCheckConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerGroupSpecHealthCheckConfig)(ptr) == nil
}

func (ServerGroupSpecHealthCheckConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerGroupSpecHealthCheckConfig)(ptr)
	var objs []ServerGroupSpecHealthCheckConfig
	if obj != nil {
		objs = []ServerGroupSpecHealthCheckConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecHealthCheckConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerGroupSpecHealthCheckConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerGroupSpecHealthCheckConfig)(ptr) = ServerGroupSpecHealthCheckConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerGroupSpecHealthCheckConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecHealthCheckConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerGroupSpecHealthCheckConfig)(ptr) = objs[0]
			} else {
				*(*ServerGroupSpecHealthCheckConfig)(ptr) = ServerGroupSpecHealthCheckConfig{}
			}
		} else {
			*(*ServerGroupSpecHealthCheckConfig)(ptr) = ServerGroupSpecHealthCheckConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ServerGroupSpecHealthCheckConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecHealthCheckConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ServerGroupSpecHealthCheckConfig)(ptr) = obj
		} else {
			*(*ServerGroupSpecHealthCheckConfig)(ptr) = ServerGroupSpecHealthCheckConfig{}
		}
	default:
		iter.ReportError("decode ServerGroupSpecHealthCheckConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerGroupSpecStickySessionConfigCodec struct {
}

func (ServerGroupSpecStickySessionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerGroupSpecStickySessionConfig)(ptr) == nil
}

func (ServerGroupSpecStickySessionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerGroupSpecStickySessionConfig)(ptr)
	var objs []ServerGroupSpecStickySessionConfig
	if obj != nil {
		objs = []ServerGroupSpecStickySessionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecStickySessionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerGroupSpecStickySessionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerGroupSpecStickySessionConfig)(ptr) = ServerGroupSpecStickySessionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerGroupSpecStickySessionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecStickySessionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerGroupSpecStickySessionConfig)(ptr) = objs[0]
			} else {
				*(*ServerGroupSpecStickySessionConfig)(ptr) = ServerGroupSpecStickySessionConfig{}
			}
		} else {
			*(*ServerGroupSpecStickySessionConfig)(ptr) = ServerGroupSpecStickySessionConfig{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj ServerGroupSpecStickySessionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerGroupSpecStickySessionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*ServerGroupSpecStickySessionConfig)(ptr) = obj
		} else {
			*(*ServerGroupSpecStickySessionConfig)(ptr) = ServerGroupSpecStickySessionConfig{}
		}
	default:
		iter.ReportError("decode ServerGroupSpecStickySessionConfig", "unexpected JSON type")
	}
}
